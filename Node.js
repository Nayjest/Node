// Generated by CoffeeScript 1.3.3

/*
Node module
*/


(function() {

  define([], function() {
    "use strict";

    var Node, _linkPc;
    _linkPc = function(parent, child) {
      if (child._parent) {
        if (child._parent === parent) {
          return;
        }
        child.detach();
      }
      parent._children.push(child);
      return child._parent = parent;
    };
    /*
      Class for organizing objects hierarchy (tree)
      Limitations: 
      * object can belongs only to one parent
      * all elements of hierarchy must be instances of Node class
    */

    return Node = (function() {
      /*
          Creates node
          @param {Node|null} parent
          @param {Array<Node>|null} children
          @return {Node} new instance
      */

      function Node(parent, children) {
        this._children = [];
        this.setParent(parent);
        this.setChildren(children);
      }

      Node.prototype.isNode = true;

      /*
          Returns list of object children
          @return {Array<Node>} children list
      */


      Node.prototype.getChildren = function() {
        return this._children;
      };

      /*
          Detaches all  children and links object to new children array
          @param {Array<Node>|null} children
          @return {Node} this
      */


      Node.prototype.setChildren = function(children) {
        var node, _i, _len;
        if (children == null) {
          children = [];
        }
        this.detachChildren();
        for (_i = 0, _len = children.length; _i < _len; _i++) {
          node = children[_i];
          this.addChild(node);
        }
        return this;
      };

      /*
          Removes all children from object
          @return {Node} this
      */


      Node.prototype.detachChildren = function() {
        var node, _i, _len, _ref;
        if (this._children.length) {
          _ref = this._children;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            node = _ref[_i];
            node.detach();
          }
        }
        return this;
      };

      /*
          @param {Node} parent
          @return {Node} this
      */


      Node.prototype.addChild = function(node) {
        _linkPc(this, node);
        return this;
      };

      /*
          @param {Node|null} parent
          @return {Node} this
      */


      Node.prototype.setParent = function(parent) {
        if (parent == null) {
          parent = null;
        }
        if (parent) {
          _linkPc(parent, this);
        } else {
          this.detach();
        }
        return this;
      };

      /*
          Returns parent object if exists
          @return {Node|null} parent if exists
      */


      Node.prototype.getParent = function() {
        return this._parent;
      };

      /*
          Returns list of parents
          @return {Array<Node>}
      */


      Node.prototype.getParents = function() {
        var next, res;
        next = this;
        res = [];
        while (next = next.getParent()) {
          res.push(next);
        }
        return res;
      };

      /*
          Returns root node
          @return {Node}
      */


      Node.prototype.getRoot = function() {
        return this.getParents().pop();
      };

      /*
          Checks that object has specified child node
          @param {Node} child
          @return {Boolean} true if child belongs to this object
      */


      Node.prototype.hasChild = function(node) {
        return this._children.indexOf(node) !== -1;
      };

      /*
          Checks that object has children    
          @return {Boolean} true if object has any children
      */


      Node.prototype.hasChildren = function() {
        return this._children.length !== 0;
      };

      /*
          Get plain array of all levels node children
          @return {Array<Node>}
      */


      Node.prototype.getChildrenDeep = function() {
        var node, res, _i, _len, _ref;
        res = this._children.slice(0);
        _ref = this._children;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          node = _ref[_i];
          res = res.concat(node.getAllChildrenRecursive());
        }
        return res;
      };

      /*
          Remove item from parents children list and set parent to null.
          If have no parent, do nothing.
          @return {Node} this
      */


      Node.prototype.detach = function() {
        if (this._parent) {
          this._parent._children.splice(this._parent._children.indexOf(this, 1));
        }
        return this;
      };

      return Node;

    })();
  });

}).call(this);
